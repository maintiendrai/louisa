---
layout: post
title: 我的Git工作流
categories:
- Tools
tags:
- GIT 
---



# Git data stores
 
![](http://ww2.sinaimg.cn/large/637573b1gw1etsbgs5we2j20dd0cnmyl.jpg)

•	workspace - 对应本地目录，当有文件修改，则最新体现在workspace变化

•	index - 是索引文件，指定commit要提交的内容

•	commit - 提交到本地仓库

•	HEAD - 表示本地最新的一次commit

•	git diff - 比较workspace与index

•	git diff -cached - 比较index与commit

•	git diff HEAD - 比较workspace与commit


![](http://ww2.sinaimg.cn/large/637573b1gw1etsbhk7uycj20e50huwgq.jpg)

# Git 工作流
  
master 用于发布  
develop 用户主要开发点  
新功能hotfix，开个功能名的分支，这个分支不 push，写好后:

`(hotfix) $ git add .`

`(hotfix) $ git commit -m "..."`

`(hotfix) $ git checkout develop`

`(develop) $ git pull origin develop`

`(develop) $ git merge hotfix `

`(develop) $ git push origin develop`

自己合并到 develop 分支，合并只是简单的 merge 就好了


# git rebase

两个人工作在一个特性分支上，push 的时候出现冲突，那么要用
git pull
还是
git pull --rebase
呢？

以前我是用第一种方式，但是后来偏好
 pull --rebase，
因为这样可以得到一个线性的特性分支，虽然丢失了并行开发的信息，而且 commit 较多的话解决冲突会变麻烦（解决方案是频繁 rebase && push）。
保持线性的特性分支，查阅很多资料都只看见“管理者的喜好”这样的描述，而没有描述优缺点。
多人协作，所以需要经常push到代码库备份。而这两个人如果经常 pull 的话，就会出现很多
Merge branch 'aaa' of git.xxx.xxx/xxx/xxx into aaa
这样的 merge commit，这时候就会发现这些merge动作其实没有必要，这些 commit 在审阅代码的时候很干扰。

![](http://ihower.tw/blog/wp-content/uploads/2010/02/git-merge.jpg)

总结了一下：
加上 rebase 的意思是， 
1. 把本地 repo. 从上次 pull 之后的变更暂存起來 
2. 回復到上次 pull 時的情況 
3. 套用远端的变更 
4. 最后再套用刚暂存下来的本地变更。
詳細說明可以參考 [](http://gitready.com/advanced/2009/02/11/pull-with-rebase.html "pull with rebase")。

用图说明下：

还没合并前：
![](http://gitbook.liuhui998.com/assets/images/figure/rebase1.png)
用git merge合并：
![](http://gitbook.liuhui998.com/assets/images/figure/rebase2.png)
用git rebase合并：
![](http://gitbook.liuhui998.com/assets/images/figure/rebase3.png)
当'mywork'分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除.
![](http://gitbook.liuhui998.com/assets/images/figure/rebase4.png)
最后是：
现在我们可以看一下用合并(merge)和用rebase所产生的历史的区别：
![](http://gitbook.liuhui998.com/assets/images/figure/rebase5.png)
(rebase 时所谓的解决冲突，其实是直接修改你之前的变更內容，所以上图中变成 C5’ 跟 c6’ )

在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用"git-add"命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行:

`$ git rebase --continue`

这样git会继续应用(apply)余下的补丁。
在任何时候，你可以用--abort参数来终止rebase的行动，并且"mywork" 分支会回到rebase开始前的状态。

`$ git rebase --abort`


参考资料:

1. [http://blog.osteele.com/posts/2008/05/my-git-workflow/#fn:1](http://blog.osteele.com/posts/2008/05/my-git-workflow/#fn:1)
2. [http://gitbook.liuhui998.com/4\_2.html](http://gitbook.liuhui998.com/4_2.html)
3. [https://ihower.tw/blog/archives/3843](https://ihower.tw/blog/archives/3843)
4. [https://getpocket.com/a/read/961298276](https://getpocket.com/a/read/961298276)
5. [http://www.oschina.net/question/54371\_59134](http://www.oschina.net/question/54371_59134)
6. [http://www.nvie.com/posts/a-successful-git-branching-model/](http://www.nvie.com/posts/a-successful-git-branching-model/)




